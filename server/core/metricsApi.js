// Recidiviz - a data platform for criminal justice reform
// Copyright (C) 2019 Recidiviz, Inc.
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.
// =============================================================================

/**
 * Utilities for retrieving and caching metrics for the app.
 *
 * In the current implementation, metrics are generated by the Recidiviz data platform and stored
 * in two separate formats as metric files in Google Cloud Storage: an optimized format as compressed
 * txt files that represent compact versions of sparse matrices, and a more readable format via
 * JSON Lines. Those files are pulled down and cached in memory with a TTL. That TTL is unaffected by
 * access to the cache, so files are re-fetched at a predictable cadence, allowing for updates to
 * those files to be quickly reflected in the app without frequent requests to GCS.
 */

const cacheManager = require('cache-manager');
const fs = require('fs');
const path = require('path');
const util = require('util');
const { unzipSync } = require('zlib');
const objectStorage = require('./objectStorage');

const BUCKET_NAME = process.env.METRIC_BUCKET;
const METRIC_CACHE_TTL_SECONDS = 60 * 60; // Expire items in the cache after 1 hour
const METRIC_REFRESH_SECONDS = 60 * 10;   // Refresh the cache in the background after cache hits that occur within 10 minutes before expiration

const memoryCache = cacheManager.caching(
  { store: 'memory', ttl: METRIC_CACHE_TTL_SECONDS, refreshThreshold: METRIC_REFRESH_SECONDS },
);
const asyncReadFile = util.promisify(fs.readFile);

const FILES_BY_METRIC_TYPE = {
  newRevocation: [
    'revocations_matrix_by_month.txt',
    'revocations_matrix_cells.txt',
    'revocations_matrix_distribution_by_district.txt',
    'revocations_matrix_distribution_by_gender.txt',
    'revocations_matrix_distribution_by_race.txt',
    'revocations_matrix_distribution_by_risk_level.txt',
    'revocations_matrix_distribution_by_violation.txt',
    'revocations_matrix_supervision_distribution_by_district.txt',
    'revocations_matrix_filtered_caseload.json',
  ],
  communityGoals: [
    'admissions_by_type_by_month.txt',
    'admissions_by_type_by_period.txt',
    'average_change_lsir_score_by_month.txt',
    'average_change_lsir_score_by_period.txt',
    'revocations_by_month.txt',
    'revocations_by_period.txt',
    'supervision_termination_by_type_by_month.txt',
    'supervision_termination_by_type_by_period.txt',
    'site_offices.json',
  ],
  communityExplore: [
    'admissions_by_type_by_month.txt',
    'admissions_by_type_by_period.txt',
    'average_change_lsir_score_by_month.txt',
    'average_change_lsir_score_by_period.txt',
    'case_terminations_by_type_by_month.txt',
    'case_terminations_by_type_by_officer_by_period.txt',
    'race_proportions.json',
    'revocations_by_month.txt',
    'revocations_by_officer_by_period.txt',
    'revocations_by_period.txt',
    'revocations_by_race_and_ethnicity_by_period.txt',
    'revocations_by_supervision_type_by_month.txt',
    'revocations_by_violation_type_by_month.txt',
    'supervision_termination_by_type_by_month.txt',
    'supervision_termination_by_type_by_period.txt',
    'site_offices.json',
  ],
  facilitiesGoals: [
    'avg_days_at_liberty_by_month.txt',
    'reincarcerations_by_month.txt',
    'reincarcerations_by_period.txt',
  ],
  facilitiesExplore: [
    'admissions_by_type_by_period.txt',
    'admissions_versus_releases_by_month.txt',
    'admissions_versus_releases_by_period.txt',
    'avg_days_at_liberty_by_month.txt',
    'reincarceration_rate_by_stay_length.txt',
    'reincarcerations_by_month.txt',
    'reincarcerations_by_period.txt',
  ],
  programmingExplore: [
    'ftr_referrals_by_age_by_period.txt',
    'ftr_referrals_by_gender_by_period.txt',
    'ftr_referrals_by_lsir_by_period.txt',
    'ftr_referrals_by_month.txt',
    'ftr_referrals_by_participation_status.txt',
    'ftr_referrals_by_period.txt',
    'ftr_referrals_by_race_and_ethnicity_by_period.txt',
    'race_proportions.json',
    'site_offices.json',
  ],
};

/**
 * Determines whether or not we should be retrieving the optimized version of the
 * metric file with the given file name and metric type. This is determined by
 * checking the extension for the given file in the mappings from metric type to
 * file name above.
 */
function inOptimizedFileWhitelist(metricType, file) {
  const files = FILES_BY_METRIC_TYPE[metricType];

  const optimizedFilename = `${file}.txt`;
  if (files.includes(optimizedFilename)) {
    return true;
  }

  const nonOptimizedFilename = `${file}.json`;
  if (files.includes(nonOptimizedFilename)) {
    return false;
  }

  throw `${file} not found with either txt or json extension for metric type ${metricType}`;
}

/**
 * Returns the given filename without the extension.
 */
function withoutExtension(filename) {
  return path.parse(filename).name;
}

/**
 * Returns the extension at the end of the given filename.
 */
function onlyExtension(filename) {
  return path.parse(filename).ext;
}

/**
 * Processes the given metric file, a Buffer of bytes, returning a json object
 * structured based on the given format.
 */
function processMetricFile(contents, metadata, extension) {
  const stringContents = contents.toString();
  if (!stringContents || stringContents.length === 0) {
    return null;
  }

  if (extension.toLowerCase() === '.json') {
    return processJsonLinesMetricFile(stringContents);
  }
  if (extension.toLowerCase() === '.txt') {
    return processOptimizedTxtMetricFile(stringContents, metadata);
  }

  return {};
}

/**
 * Processes a Json Lines formatted metric file. This consists of the string contents
 * of a file which is formatted with a single JSON object on each line. Each object
 * is a single data point. These are returned as an array of Javascript objects.
 */
function processJsonLinesMetricFile(stringContents) {
  const jsonObject = [];
  const splitStrings = stringContents.split('\n');
  splitStrings.forEach((line) => {
    if (line) {
      jsonObject.push(JSON.parse(line));
    }
  });

  return jsonObject;
}

/**
 * Processes our optimized format metric file. This consists of a single,
 * flattened array that can be expanded into a compact matrix from which
 * data points can be located via metadata. The returned object has two keys:
 *   - `flattenedValueMatrix`: A comma-separated string of values which is a flattened
 *                             version of a collection of arrays forming a compact
 *                             representation of a sparse matrix.
 *   - `metadata`: An object with the metadata required to parse values from the
 *                 flattenedValueMatrix
 */
function processOptimizedTxtMetricFile(stringContents, metadata) {
  try {
    const decompressedStringContents = unzipSync(stringContents);
    console.log('Decompressed file...');
    return { flattenedValueMatrix: decompressedStringContents, metadata };
  } catch (error) {
    console.error('An error occurred during decompression, assuming already decompressed...', error.code, error.errno);
    return { flattenedValueMatrix: stringContents, metadata };
  }
}

/**
 * Retrieves the names of all of the files which are available for the given metric type,
 * with the filenames that are hard-coded for each file.
 *
 * If a specific file is requested, this checks that the file is available for the
 * given metric type, and sets the proper extension on the filename.
 */
function filesForMetricType(metricType, file) {
  const files = FILES_BY_METRIC_TYPE[metricType];

  if (file) {
    const extension = inOptimizedFileWhitelist(metricType, file) ? '.txt' : '.json';
    const normalizedFile = `${file}${extension}`;
    if (files.indexOf(normalizedFile) > -1) {
      return [normalizedFile];
    }
    throw new Error(`Metric file ${normalizedFile} not registered for metric type ${metricType}`);
  }

  return files;
}

/**
 * Retrieves all metric files for the given metric type from Google Cloud Storage.
 *
 * Returns a list of Promises, one per metric file for the given type, where each Promise will
 * eventually return either an error or an object with the following keys:
 *   - `fileKey`: a unique key for identifying the metric file, e.g. 'revocations_by_month'
 *   - `extension`: the extension of the metric file, either .txt or .json
 *   - `contents`: the contents of the file deserialized into JS objects/arrays
 *   - `metadata`: (optional) the metadata of the metric file, if it is in the
                   optimized (compressed .txt) format
 */
function fetchMetricsFromGCS(stateCode, metricType, file) {
  const promises = [];

  const files = filesForMetricType(metricType, file);
  files.forEach((filename) => {
    const fileKey = withoutExtension(filename);
    const extension = onlyExtension(filename);

    const filePromise = objectStorage.downloadFile(BUCKET_NAME, stateCode, filename);
    const metadataPromise = objectStorage.downloadFileMetadata(BUCKET_NAME, stateCode, filename);

    promises.push(Promise.all([filePromise, metadataPromise])
      .then((bothResults) => {
        const contents = bothResults[0];
        const rawMetadata = bothResults[1][0].metadata;

        const metadata = {};
        if (rawMetadata) {
          metadata.value_keys = JSON.parse(rawMetadata.value_keys);
          metadata.total_data_points = rawMetadata.total_data_points;
          metadata.dimension_manifest = JSON.parse(rawMetadata.dimension_manifest);
        }

        return { fileKey, extension, metadata, contents };
      }));
  });

  return promises;
}

/**
 * This is a parallel to fetchMetricsFromGCS, but instead fetches metric files from the local
 * file system. The return format, a list of Promises that resolve to an object with the
 * keys desecribed therein, is identical.
 */
function fetchMetricsFromLocal(stateCode, metricType, file) {
  const promises = [];

  const files = filesForMetricType(metricType, file);
  files.forEach((filename) => {
    const fileKey = withoutExtension(filename);
    const extension = onlyExtension(filename);
    const filePath = path.resolve(__dirname, `./demo_data/${filename}`);

    let metadata = {};
    if (extension == '.txt') {
      const metadataFilePath = path.resolve(
        __dirname, `./demo_data/${fileKey}.metadata.json`);

        let metadataContents = fs.readFileSync(metadataFilePath);
        metadata = JSON.parse(metadataContents);
    }

    promises.push(asyncReadFile(filePath).then(
      (contents) => ({ fileKey, extension, metadata, contents }))
    );
  });

  return promises;
}

/**
 * Retrieves the metrics for the given metric type and passes them into the given callback.
 *
 * The callback should be a function with a signature of `function (error, results)`. `results` is
 * a single object with keys mapping to individual metric files and values corresponding to the
 * deserialized contents of those files.
 *
 * First checks the cache to see if the metrics with the given type are already in memory and not
 * expired beyond the configured TTL. If not, then fetches the metrics for that type from the
 * appropriate files and invokes the callback only once all files have been retrieved.
 *
 * If we are in demo mode, then fetches the files from a static directory, /server/core/demo_data/.
 * Otherwise, fetches from Google Cloud Storage.
 */
function fetchMetrics(stateCode, metricType, file, isDemo, callback) {
  const cacheKey = `${stateCode}-${metricType}-${file}`;
  console.log(`Handling call to fetch ${cacheKey} metrics...`);

  return memoryCache.wrap(cacheKey, (cacheCb) => {
    let fetcher = null;
    let source = null;
    if (isDemo) {
      source = 'local';
      fetcher = fetchMetricsFromLocal;
    } else {
      source = 'GCS';
      fetcher = fetchMetricsFromGCS;
    }

    console.log(`Fetching ${cacheKey} metrics from ${source}...`);
    const metricPromises = fetcher(stateCode.toUpperCase(), metricType, file);

    Promise.all(metricPromises).then((allFileContents) => {
      const results = {};
      allFileContents.forEach((contents) => {
        console.log(`Fetched contents for fileKey ${contents.fileKey}`);
        const processedResponse = processMetricFile(
          contents.contents, contents.metadata, contents.extension);
        results[contents.fileKey] = processedResponse;
      });

      console.log(`Fetched all ${cacheKey} metrics from ${source}`);
      cacheCb(null, results);
    });
  }, callback);
}

function fetchNewRevocationMetrics(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'newRevocation', null, isDemo, callback);
}

function fetchNewRevocationFile(isDemo, stateCode, file, callback) {
  return fetchMetrics(stateCode, 'newRevocation', file, isDemo, callback);
}

function fetchCommunityGoals(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'communityGoals', null, isDemo, callback);
}

function fetchCommunityExplore(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'communityExplore', null, isDemo, callback);
}

function fetchFacilitiesGoals(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'facilitiesGoals', null, isDemo, callback);
}

function fetchFacilitiesExplore(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'facilitiesExplore', null, isDemo, callback);
}

function fetchProgrammingExplore(isDemo, stateCode, callback) {
  return fetchMetrics(stateCode, 'programmingExplore', null, isDemo, callback);
}

module.exports = {
  fetchNewRevocationMetrics,
  fetchNewRevocationFile,
  fetchCommunityGoals,
  fetchCommunityExplore,
  fetchFacilitiesGoals,
  fetchFacilitiesExplore,
  fetchProgrammingExplore,
};
